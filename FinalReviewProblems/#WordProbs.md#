#Word Problems 

The short answer section of the practice exam.

####1. What's the difference between ```sed``` and ```grep```? 
-      sed edits/replaces
-      grep finds 

####2.1 What does the following script print out? (Prob2.txt)
```
#!/bin/grep is
this
is
```
*Note*: If the bash prompt errors out to `-bash: ./Prob2.txt: /bin/grep: bad interpreter: No such file or directory`, try to run the code on the linux server

####2.2 What about 
```
#! /usr/bin/env	python
```

Correct output: 
```
SyntaxError: invalid syntax
```

Explanation: Python has a different syntax, you at least need to call the main function to execute

####3. What's a symbolic link (soft link), and how is it different from a non-symbolic (hard) link? 
-      A symbolic link contains the name(reference) of the file it's pointing to
-      A hard link's file has the same inode as the original file, therefore it's the same data block on the hard drive and doesn't waste space!

####4. When you don't know how to do something in Linux, what should you do first?
-      use ```man``` to look at manuals for commands
-      use ```apropos``` to search for commands whose descriptions contain a certain keyword
-      use ```whatis``` to search for commands whose **names** contain a certain keyword/phrase

####5. What's stored on a thread's (or process' for single-threaded applications) **stack**?
-      Local variables/buffers
-      Function arguments
-      return addresses
-      old base pointers

####5.1 What is buffer overflow?
In short, a buffer overflow is caused by the manipulation of a computer's memory to control program execution. They're mainly **stack based** or **heap based**.
Some languages, such as C and C++, are prone to buffer overflows as they have no built-in protection against accessing or overwriting data.
-	A buffer overflow happens when 
	1.	 A program (malicious) attempts to put more data (take up more memory) than the buffer is supposed to hold
	2.	 A program attempts to put the data in a memory area (what's set aside for the function) that's past the buffer
	-	 This can crash the program, corrupt data, or cause the execution of malicious code
-	It's a **software security vulnerability*** 
-	In a classic buffer overflow, the call stack is overwritten and the function's return pointer is set to transfer control to malicious code when it returns
- 	Buffer overflow typically happens in 
	1.     External Data: Programs that relies on external data to control its behavior
	2.     Program that depends on the properties of data that's external to the scope of the code
	3.     Programs that're overly complex, whose behavior the programmer cannot actually predict

####6. As part of a class project you and a partner share access to an svn repository hosted on the class server. One night, without your knowledge, your partner adds a backdoor (a secret piece of code allowing remote control of the project) to the project repository. However, you do not realize this until after the project is turned in. How can you show (with reasonable certainty) that you did not add the back door to the project? List the specific commands you would use and what useful information they would provide.

Because it's not a distributed version control system, we can use ```svn log``` which shows you the author information of the commit 

####7. In 2009 an attack on SSL (Secure Socket Layer) Certificates was published online that allowed spoofing of domain names. This attack allowed a malicious site to publish valid security certificates which appeared to be for a different site. For example, www.goodsite.com.evilsite.com (a subdomain of evilsite.com) would claim to be www.goodsite.com by having a non-printable null character (œôòüwww.goodsite.com\0.evilsite.comœôòý) in its name. Given that every domain name is exactly 32 characters (with null byes on the end when less than 32 characters are used), eliminate this spoofing vulnerability from the following function:
```c
/* Returns 0 when the certificate is valid for the site and non-zero otherwise*/ int isValidForSite(char* domainName, char* certificateDomainName)
{
return strcmp(domainName, certificateDomainName);
}
```
**Answer**:
```
Last login: Tue Dec  6 16:01:31 on ttys005
s-128-97-51-11:~ wandi$ bash 
bash-3.2$ bash again
bash: again: No such file or directory
bash-3.2$ hello
bash: hello: command not found
bash-3.2$ echo hello
hello
bash-3.2$ man hello
No manual entry for hello
bash-3.2$ man bash
bash-3.2$ help
GNU bash, version 3.2.57(1)-release (x86_64-apple-darwin16)
These shell commands are defined internally.  Type `help' to see this list.
Type `help name' to find out more about the function `name'.
Use `info bash' to find out more about the shell in general.
Use `man -k' or `info' to find out more about commands not in this list.

A star (*) next to a name means that the command is disabled.

 JOB_SPEC [&]                       (( expression ))
 . filename [arguments]             :
 [ arg... ]                         [[ expression ]]
 alias [-p] [name[=value] ... ]     bg [job_spec ...]
 bind [-lpvsPVS] [-m keymap] [-f fi break [n]
 builtin [shell-builtin [arg ...]]  caller [EXPR]
 case WORD in [PATTERN [| PATTERN]. cd [-L|-P] [dir]
 command [-pVv] command [arg ...]   compgen [-abcdefgjksuv] [-o option
 complete [-abcdefgjksuv] [-pr] [-o continue [n]
 declare [-afFirtx] [-p] [name[=val dirs [-clpv] [+N] [-N]
 disown [-h] [-ar] [jobspec ...]    echo [-neE] [arg ...]
 enable [-pnds] [-a] [-f filename]  eval [arg ...]
 exec [-cl] [-a name] file [redirec exit [n]
 export [-nf] [name[=value] ...] or false
 fc [-e ename] [-nlr] [first] [last fg [job_spec]
 for NAME [in WORDS ... ;] do COMMA for (( exp1; exp2; exp3 )); do COM
 function NAME { COMMANDS ; } or NA getopts optstring name [arg]
 hash [-lr] [-p pathname] [-dt] [na help [-s] [pattern ...]
 history [-c] [-d offset] [n] or hi if COMMANDS; then COMMANDS; [ elif
 jobs [-lnprs] [jobspec ...] or job kill [-s sigspec | -n signum | -si
 let arg [arg ...]                  local name[=value] ...
 logout                             popd [+N | -N] [-n]
 printf [-v var] format [arguments] pushd [dir | +N | -N] [-n]
 pwd [-LP]                          read [-ers] [-u fd] [-t timeout] [
 readonly [-af] [name[=value] ...]  return [n]
 select NAME [in WORDS ... ;] do CO set [--abefhkmnptuvxBCHP] [-o opti
 shift [n]                          shopt [-pqsu] [-o long-option] opt
 source filename [arguments]        suspend [-f]
 test [expr]                        time [-p] PIPELINE
 times                              trap [-lp] [arg signal_spec ...]
 true                               type [-afptP] name [name ...]
 typeset [-afFirtx] [-p] name[=valu ulimit [-SHacdfilmnpqstuvx] [limit
 umask [-p] [-S] [mode]             unalias [-a] name [name ...]
 unset [-f] [-v] [name ...]         until COMMANDS; do COMMANDS; done
 variables - Some variable names an wait [n]
 while COMMANDS; do COMMANDS; done  { COMMANDS ; }
bash-3.2$ help read
read: read [-ers] [-u fd] [-t timeout] [-p prompt] [-a array] [-n nchars] [-d delim] [name ...]
    One line is read from the standard input, or from file descriptor FD if the
    -u option is supplied, and the first word is assigned to the first NAME,
    the second word to the second NAME, and so on, with leftover words assigned
    to the last NAME.  Only the characters found in $IFS are recognized as word
    delimiters.  If no NAMEs are supplied, the line read is stored in the REPLY
    variable.  If the -r option is given, this signifies `raw' input, and
    backslash escaping is disabled.  The -d option causes read to continue
    until the first character of DELIM is read, rather than newline.  If the -p
    option is supplied, the string PROMPT is output without a trailing newline
    before attempting to read.  If -a is supplied, the words read are assigned
    to sequential indices of ARRAY, starting at zero.  If -e is supplied and
    the shell is interactive, readline is used to obtain the line.  If -n is
    supplied with a non-zero NCHARS argument, read returns after NCHARS
    characters have been read.  The -s option causes input coming from a
    terminal to not be echoed.
    
    The -t option causes read to time out and return failure if a complete line
    of input is not read within TIMEOUT seconds.  If the TMOUT variable is set,
    its value is the default timeout.  The return code is zero, unless end-of-file
    is encountered, read times out, or an invalid file descriptor is supplied as
    the argument to -u.
readonly: readonly [-af] [name[=value] ...] or readonly -p
    The given NAMEs are marked readonly and the values of these NAMEs may
    not be changed by subsequent assignment.  If the -f option is given,
    then functions corresponding to the NAMEs are so marked.  If no
    arguments are given, or if `-p' is given, a list of all readonly names
    is printed.  The `-a' option means to treat each NAME as
    an array variable.  An argument of `--' disables further option
    processing.
bash-3.2$ man man
bash-3.2$ man apropos
bash-3.2$ exit 
exit
s-128-97-51-11:~ wandi$ apropos SneakyChef
SneakyChef: nothing appropriate
s-128-97-51-11:~ wandi$ apropos man
brew(1)                  - The missing package manager for OS X
DataDetectorsLocalSources(8) - DataDetectors user source content manager
SafeBase(ntcl), Safe Base(ntcl) - A mechanism for creating and manipulating safe interpreters
Tcl(ntcl)                - Tool Command Language
TclX(n)                  - Extended Tcl: Extended command set for Tcl '
after(ntcl)              - Execute a command after a time delay
ani(1)                   - Apple Net Install command line tool
apply(1)                 - apply a command to a set of arguments
array(ntcl)              - Manipulate array variables
asl.conf(5)              - configuration file for syslogd(8) and aslmanager(8)
aslmanager(8)            - Apple System Log data life-cycle manager
audit(8)                 - audit management utility
auditd(8)                - audit log management daemon
avbdeviced(1)            - peristent entity management for AVB
avbutil(1)               - manage AVB features and settings
bgerror(ntcl)            - Command invoked to process background errors
brctl(1)                 - Manage the CloudDocs daemon
break(ntcl)              - Abort looping command
builtin(1), !(1), %(1), .(1), :(1), @(1), {(1), }(1), alias(1), alloc(1), bg(1), bind(1), bindkey(1), break(1), breaksw(1), builtins(1), case(1), cd(1), chdir(1), command(1), complete(1), continue(1), default(1), dirs(1), do(1), done(1), echo(1), echotc(1), elif(1), else(1), end(1), endif(1), endsw(1), esac(1), eval(1)s-128-97-51-11:~ wandi$ man apropos
s-128-97-51-11:~ wandi$ cd CS35L/
s-128-97-51-11:CS35L wandi$ cd FinalReviewProblems/
s-128-97-51-11:FinalReviewProblems wandi$ touch Prob2.txt
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob2.txt 
s-128-97-51-11:FinalReviewProblems wandi$ make Prob2.txt
make: Nothing to be done for `Prob2.txt'.
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob2.o Prob2.txt
clang: error: no such file or directory: 'Prob2.o'
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob2.txt Prob2
clang: error: no such file or directory: 'Prob2'
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob2.txt -o Prob2
ld: warning: ignoring file Prob2.txt, file was built for unsupported file format ( 0x23 0x21 0x2F 0x62 0x69 0x6E 0x2F 0x67 0x72 0x65 0x70 0x20 0x69 0x73 0x0A 0x48 ) which is not the architecture being linked (x86_64): Prob2.txt
Undefined symbols for architecture x86_64:
  "_main", referenced from:
     implicit entry/start for main executable
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
s-128-97-51-11:FinalReviewProblems wandi$ ./Prob2.txt
-bash: ./Prob2.txt: Permission denied
s-128-97-51-11:FinalReviewProblems wandi$ chmod +x Prob2.txt
s-128-97-51-11:FinalReviewProblems wandi$ ./Prob2.txt 
-bash: ./Prob2.txt: /bin/grep: bad interpreter: No such file or directory
s-128-97-51-11:FinalReviewProblems wandi$ cat Prob2.txt
#!/bin/grep is
Hello
this
is
a test!
s-128-97-51-11:FinalReviewProblems wandi$ touch Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c 
s-128-97-51-11:FinalReviewProblems wandi$ chmod +x Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob7.c -o Prob7.o
Prob7.c:13:11: error: use of undeclared identifier 'false'; did you mean 'else'?
          return false;
                 ^~~~~
                 else
Prob7.c:13:11: error: expected expression
2 errors generated.
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob7.c -o Prob7.o
Prob7.c:15:11: error: use of undeclared identifier 'false'; did you mean 'else'?
          return false;
                 ^~~~~
                 else
Prob7.c:15:11: error: expected expression
Prob7.c:24:2: error: expected '}'
}
 ^
Prob7.c:4:1: note: to match this '{'
{
^
3 errors generated.
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob7.c -o Prob7.o
Prob7.c:13:11: error: use of undeclared identifier 'false'; did you mean 'else'?
          return false;
                 ^~~~~
                 else
Prob7.c:13:11: error: expected expression
Prob7.c:21:2: error: expected '}'
}
 ^
Prob7.c:4:1: note: to match this '{'
{
^
3 errors generated.
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob7.c -o Prob7.o
Prob7.c:12:11: error: use of undeclared identifier 'false'; did you mean 'else'?
          return false;
                 ^~~~~
                 else
Prob7.c:12:11: error: expected expression
2 errors generated.
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob7.c -o Prob7.o
Undefined symbols for architecture x86_64:
  "_main", referenced from:
     implicit entry/start for main executable
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
s-128-97-51-11:FinalReviewProblems wandi$ 
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob7.c -o Prob7.o
Prob7.c:23:3: error: use of undeclared identifier 'string'
  string a = "12345678901234567890123456789012";
  ^
Prob7.c:24:3: error: use of undeclared identifier 'string'
  string b = "12345678901234567890123456789012";
  ^
Prob7.c:25:15: error: use of undeclared identifier 'a'
  char *p1 = &a;
              ^
Prob7.c:26:15: error: use of undeclared identifier 'b'
  char *p2 = &b;
              ^
4 errors generated.
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob7.c -o Prob7.o
s-128-97-51-11:FinalReviewProblems wandi$ ./Prob7.o
yayys-128-97-51-11:FinalReviewProblems wandi$ ls
#WordProbs.md#			       Prob2.txt~	Prob7.c~	README.md
Prob2.txt			       Prob7.c				Prob7.o		WordProbs.md
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c

[1]+  Stopped                 emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob7.c -o Prob7.o
Prob7.c:34:65: error: expected ';' after expression
    printf("Same strings verified! (both with null characters)")
                                                                ^
                                                                ;
1 error generated.
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob7.c -o Prob7.o
s-128-97-51-11:FinalReviewProblems wandi$ ./Prob7.o
Same strings verified!Malignant string detected!Same strings verified! (both with null characters)s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c
s-128-97-51-11:FinalReviewProblems wandi$ ./Prob7.o
Same strings verified!Malignant string detected!Same strings verified! (both with null characters)s-128-97-51-11:FinalReviewProblems wandi$ gcc Prob7.c -o Prob7.o
s-128-97-51-11:FinalReviewProblems wandi$ ./Prob7.o
Same strings verified!
Malignant string detected!
Same strings verified! (both with null characters)
s-128-97-51-11:FinalReviewProblems wandi$ emacs Prob7.c

  char * p4 = "12345678901234567890123\0456789012";
  if (isValidForSite(p1, p2) == 0){
    printf("Same strings verified!\n");
  }
  if (isValidForSite(p2, p3) ==1){
    printf("Malignant string detected!\n");
  }
  if (isValidForSite(p3, p4) == 0){
    printf("Same strings verified! (both with null characters)\n");
  }
}